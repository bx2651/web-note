一个类或对象中往往会包含别的对象，在创建这种成员对象时，可以使用常规的方式，也可以使用new关键字和类构造函数，问题在于这会导致相关的两个类之间产生依赖性。

## 简单工厂模式

我们假设现在某个系统成员角色有两种：超级管理员和普通游客，分别对应两种不同的权限。

```
let  factory = function (role) {
	function superman() {
	    this.name ='超级管理员',
	    this.role = ['修改密码', '发布消息', '查看主页']
	}

	function commonMan() {
	    this.name = '普通游客',
	    this.role = ['查看主页']
	}
	
	switch(role) {
	    case 'superman':
	    return new superman();
	    break;
	    case 'man':
	    return new commonMan();
	    break;
	    default:
	    throw new Error('参数错误')
	}

}

let superman = factory('superman');
let man = factory('man');

```

当某一天我们需要新增某个角色时，我们不仅需要增加对应的角色的方法，还需要在switch中增加对应的选择。

当然，我们可以优化一下这段代码：

```
let factory = function (role) {
  function User(obj) {
    this.name = obj.name;
    this.role = obj.role;
  }
  switch (role) {
    case 'superman':
      return new User({ name: '平台用户', role: ['主页', '登录页'] })
      break;
    case 'man':
      return new User({ name: '游客', role: ['登录页'] })
      break;
    default:
      throw new Error('参数错误')
  }
}

let superman = factory('superman');
let man = factory('man');

```


```
abstract class Coffee {
  constructor(public name: string) { }
}

class AmericanoCoffee extends Coffee { }
class LatteCoffee extends Coffee { }
class CappuccinoCoffee extends Coffee { }

class CafeFactory {
  static order(name: string) {
    switch (name) {
      case "AmericanoCoffee":
        return new AmericanoCoffee('美式')
      case "LatteCoffee":
        return new LatteCoffee('拿铁')
      case "CappuccinoCoffee":
        return new CappuccinoCoffee('卡布奇诺')
      default:
        throw new Error('不存在')
    }
  }
}

```

> 简单工厂就是函数里返回类的实例


## 工厂方法模式

工厂方法模式又称为多态性工厂模式。

在工厂方法模式中，核心的工厂类不再负责所有的产品的创建，而是将具体创建工作交给工厂子类去做。

```
abstract class Coffee {
  constructor(public name: string) { }
}

class AmericanoCoffee extends Coffee { }
class LatteCoffee extends Coffee { }
class CappuccinoCoffee extends Coffee { }

abstract class CafeFactory {
  abstract createCoffee():Coffee
}

class AmericanoCoffeeFactory extends CafeFactory{
  createCoffee(){
    return new AmericanoCoffee('美式')
  }
}
class LatteCoffeeFactory extends CafeFactory{
  createCoffee(){
    return new LatteCoffee('拿铁')
  }
}
class CappuccinoCoffeeFactory extends CafeFactory{
  createCoffee(){
    return new CappuccinoCoffee('卡布奇诺')
  }
}


let america = new AmericanoCoffeeFactory().createCoffee()
let lattee = new LatteCoffeeFactory().createCoffee()
let cappucuino = new CappuccinoCoffeeFactory().createCoffee()
```



## 复杂工厂模式

复杂工厂模式的核心在于，将成员对象的实例化推迟到子类中进行：

```
let factory = function (role) {
  if (this instanceof factory) {
    var s = new this[role]();
    return s;
  } else {
    return new factory(role);
  }
}

factory.prototype = {
  admin: function () {
    this.name = '平台用户';
    this.role = ['登录页', '主页']

  },
  common: function () {
    this.name = '游客';
    this.role = ['登录页']
  },
  test: function () {
    this.name = '测试';
    this.role = ['登录页', '主页', '测试页'];
    this.test = '我还有一个测试属性哦'
  }
}

let admin = new factory('admin');
let common = new factory('common');
let test = new factory('test');

```