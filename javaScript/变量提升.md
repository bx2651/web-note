## 先说总结性的话：

let 的「创建」过程被提升了，但是初始化没有提升。

var 的「创建」和「初始化」都被提升了。

function 的「创建」「初始化」和「赋值」都被提升了。

未经声明的变量，不会被提升。

## 变量提升的规律
在进入一个执行上下文后，先把 var 和 function 声明的变量前置，再去顺序执行代码。

PS：作用域分为全局作用域和函数作用域，用var声明的变量，只在自己所在的所用域有效。

代码如下：

```
var a = "abc";
function fn(){
    console.log(a); //undefined
    var a = "cde";
    console.log(a); //cde
}
fn();
console.log(a); //abc
```

上面代码中，局部变量在整个函数体中的声明被提前，从而遮盖了全局变量的赋值，所以函数部分的代码其实相当于：

```
function fn(){
	var a;
	console.log(a);
	a = "cde";
	console.log(a);
}
```

而由于函数体内的a为局部变量，所以在全局作用于下，变量a的值仍然为abc。    

## 函数提升的规律

1.函数声明：function fun(a){console.log(a)};只用通过函数声明的函数会被提升，其创建、初始化、赋值都会被提升，如下所示：

```
console.log(fn);//ƒ fn(){}
function fn(){};

```

控制台不会报错，而是任劳任怨的在全局作用域下找到了这个函数并输出。同样，如果是在函数被声明之前调用函数，也不会有任何问题。


2.函数表达式：var fun = function(a){console.log(a)};通过函数表达式声明的函数不会被提升

3.构造函数：var fun = new Function("a",console.log(a));  通过构造函数声明的函数不会被提升  